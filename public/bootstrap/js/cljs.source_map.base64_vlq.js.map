{"version":3,"sources":["cljs/source_map/base64_vlq.cljs"],"mappings":";AAaA,AAAA,AAAaA;AACb,AAAaC,AAAS,AAAA,AAAkBD,AAAA;AACxC,AAAaE,AAAc,AAAA,AAAKD;AAChC,AAAaE,AAAqBF;AAElC,AAAA,AAAMG,AAAeC;AAArB,AACE,AAAI,AAAA,AAAMA;AACR,AAAA,AAAK,AAAA,AAAgB,AAAGA;;AACxB,AAAA,AAAG,AAAA,AAAgBA;;;AAEvB,AAAA,AAAMC,AAAiBD;AAAvB,AACE,AAAME,AAAK,AAAA,AAACC,AAAE,AAAA,AAASH;AACjBI,AAAQ,AAAA,AAAiBJ;AAD/B,AAEE,AAAIE;AACF,AAAGE;;AACHA;;;AAEN,AAAA,AAAMC,AAAYC;AAAlB,AACE,AAAMC,AAAG,AAAAC;AACHC,AAAI,AAACV,AAAcO;AADzB,AAEE,AAAOI,AAAM,AAASD,AAAIZ;AACnBY,AAAM,AAA2BA,AAAId,AAAA;;AAD5C,AAEE,AAAI,AAAA,AAAMc;AACR,AAAMC,AAAM,AAAQA,AAAMZ;AAA1B,AACE,AAASS,AAAG,AAACI,AAAcD;;AAC3B,AAAO,AAASD,AAAIZ;AACb,AAA2BY,AAAId,AAAA;;;;;AACxC,AAASY,AAAG,AAACI,AAAcD;;;;;AAC/B,AAAKH;;AAET,AAAA,AAAMK,AAAQZ;AAAd,AACE,AAACa,AAAMC,AAAI,AAACC,AAAIV,AAAWL;;AAE7B,AAAA,AAAMgB,AAAQC;AAAd,AACE,AAAMC,AAAE,AAAUD;AAAlB,AACE,AAAA,AAAOE;AAAP,AAAWC;AAAX,AAAoBC;;AAApB,AACE,AAAM,AAAIF,AAAED;AAAZ,AACE,AAAO,AAAAI,AAAA;;AADT;;AAEA,AAAMZ,AAAM,AAACa,AAAc,AAASN,AAAEE;AAAtC,AACE,AAAMA,AAAE,AAAA,AAAKA;AACPK,AAAc,AAAA,AAAM,AAASd,AAAMZ;AACnCY,AAAM,AAASA,AAAMb;AACrBuB,AAAO,AAAGA,AAAO,AAAgBV,AAAMW;AACvCA,AAAM,AAAGA,AAAM1B,AAAA;AAJrB,AAKE,AAAI6B;AACF,AAAOL;AAAEC;AAAOC;;;;;;AAChB,AAAAI,AAAA,AAAA;;AAAA,AACC,AAACC,AAAK,AAACzB,AAAgBmB,AACjB,AAAMH,AAAE,AAAYA,AAAEE;AAAtB,AACE,AAAU,AAACQ,AAAcV;AAAzB;;AAAA,AACE,AAACD,AAAAA,AAAAA,AAAOC,AAAAA;;;;AAJnB,AAAA;;;;;AAMZ","names":["cljs.source-map.base64-vlq/vlq-base-shift","cljs.source-map.base64-vlq/vlq-base","cljs.source-map.base64-vlq/vlq-base-mask","cljs.source-map.base64-vlq/vlq-continuation-bit","cljs.source-map.base64-vlq/to-vlq-signed","v","cljs.source-map.base64-vlq/from-vlq-signed","neg?","cljs.core._EQ_","shifted","cljs.source-map.base64-vlq/encode-val","n","sb","js/goog.string.StringBuffer","vlq","digit","cljs.source-map.base64/encode","cljs.source-map.base64-vlq/encode","cljs.core.apply","cljs.core/str","cljs.core.map","cljs.source-map.base64-vlq/decode","s","l","i","result","shift","js/Error","cljs.source-map.base64/decode","continuation?","cljs.core/LazySeq","cljs.core/cons","clojure.string/blank?"],"sourcesContent":[";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.source-map.base64-vlq\n  (:require [clojure.string :as string]\n            [cljs.source-map.base64 :as base64])\n  (:import [goog.string StringBuffer]))\n\n(def ^:const vlq-base-shift 5)\n(def ^:const vlq-base (bit-shift-left 1 vlq-base-shift))\n(def ^:const vlq-base-mask (dec vlq-base))\n(def ^:const vlq-continuation-bit vlq-base)\n\n(defn to-vlq-signed [v]\n  (if (neg? v)\n    (inc (bit-shift-left (- v) 1))\n    (+ (bit-shift-left v 1) 0)))\n\n(defn from-vlq-signed [v]\n  (let [neg? (= (bit-and v 1) 1)\n        shifted (bit-shift-right v 1)]\n    (if neg?\n      (- shifted)\n      shifted)))\n\n(defn encode-val [n]\n  (let [sb (StringBuffer.)\n        vlq (to-vlq-signed n)]\n    (loop [digit (bit-and vlq vlq-base-mask)\n           vlq   (bit-shift-right-zero-fill vlq vlq-base-shift)]\n      (if (pos? vlq)\n        (let [digit (bit-or digit vlq-continuation-bit)]\n          (.append sb (base64/encode digit))\n          (recur (bit-and vlq vlq-base-mask)\n                 (bit-shift-right-zero-fill vlq vlq-base-shift)))\n        (.append sb (base64/encode digit))))\n    (str sb)))\n\n(defn encode [v]\n  (apply str (map encode-val v)))\n\n(defn decode [s]\n  (let [l (.-length s)]\n    (loop [i 0 result 0 shift 0]\n      (when (>= i l)\n        (throw (js/Error. \"Expected more digits in base 64 VLQ value.\")))\n      (let [digit (base64/decode (.charAt s i))]\n        (let [i (inc i)\n              continuation? (pos? (bit-and digit vlq-continuation-bit))\n              digit (bit-and digit vlq-base-mask)\n              result (+ result (bit-shift-left digit shift))\n              shift (+ shift vlq-base-shift)]\n          (if continuation?\n            (recur i result shift)\n            (lazy-seq\n             (cons (from-vlq-signed result)\n                   (let [s (.substring s i)]\n                     (when-not (string/blank? s)\n                       (decode s)))))))))))\n\n(comment\n  ;; tests\n\n  (bit-shift-right-zero-fill 127 1) ;; 63\n  (bit-shift-right-zero-fill -127 1) ;; 2147483584\n  \n  (to-vlq-signed 32) ;; 64\n  (to-vlq-signed -32) ;; 65\n  (from-vlq-signed 64) ;; 32\n  (from-vlq-signed 65) ;; -32\n\n  ;; Base64 VLQ can only represent 32bit values\n\n  (encode-val 32) ; \"gC\"\n  (decode \"gC\") ; {:value 32 :rest \"\"}\n\n  (decode \"AAgBC\") ; (0 0 16 1)\n  \n  ;; lines kept count by semicolons, segments delimited by commas\n  ;; the above is gline 0, gcol 0, file 0, line 16, col 1, no name if this was the first segment read\n\n  (decode \"AAggBC\") ; very clever way to encode large values\n  (decode \"AAggBCA\") ; 5 values instead of 4\n\n  (encode [0 0 16 1]) ; \"AAgBC\"\n\n  (decode \"IAWdD\") ; (4 0 11 -14 -1) this is correct\n  ;; gline N, gcol +4, file +0, line +11, col -14, name -1\n\n  ;; Notes about format\n  ;; we always have 1, 4, or 5 values, all zero-based indexes\n  ;; 1. generated col - relative - reset on every new line in generated source\n  ;; 2. index into sources list - relative\n  ;; 3. original line - relative\n  ;; 4. origin column - relative\n  ;; 5. name - relative\n  )\n"]}